(defpackage :pxp.printer (:use :cl)
  (:shadow . #0=(pprint-logical-block pprint-pop pprint-exit-if-list-exhausted
				      pprint-newline pprint-indent pprint-tab
				      pprint-linear pprint-fill pprint-tabular
				      write print prin1 princ pprint write-string write-line fresh-line
				      write-to-string prin1-to-string princ-to-string))
  (:export . #0#)
  (:export
    #:*current-length*
    #:pprint-logical-block+
    #:pprint-pop+
    #:write+))
(in-package :pxp.printer)

(defvar *current-length* 0
  "current position in logical block.")

(defvar *prefix*)

(declaim (ftype (function (pxp.stream:xp-structure t boolean)
			  (values boolean &optional))
		check-block-abbreviation))
(defun check-block-abbreviation (xp args circle-check?)
  (cond ((not (listp args)) (write+ args xp) T)
	((and *print-level* (> pxp.dispatch:*current-level* *print-level*))
	 (pxp.stream:write-char++ #\# XP) (setq pxp.stream:*abbreviation-happened* T) T)
	((and pxp.stream:*circularity-hash-table* circle-check?
	      (eq (pxp.stream:circularity-process xp args nil) :subsequent)) T)
	(T nil)))

(declaim (ftype (function (t pxp.stream:xp-structure) (values boolean &optional)) pprint-pop-check+))
(defun pprint-pop-check+ (args xp)
  (incf *current-length*)
  (cond ((not (listp args))  ;must be first so supersedes length abbrev
	 (pxp.stream:write-string++ ". " xp 0 2)
	 (write+ args xp)
	 T)
	((and *print-length* ;must supersede circle check
	      (not (< *current-length* *print-length*)))
	 (pxp.stream:write-string++ "..." xp 0 3)
	 (setq pxp.stream:*abbreviation-happened* T)
	 T)
	((and pxp.stream:*circularity-hash-table* (not (zerop *current-length*)))
	 (case (pxp.stream:circularity-process xp args T)
	   (:first ;; note must inhibit rechecking of circularity for args.
		   (write+ (cons (car args) (cdr args)) xp) T)
	   (:subsequent T)
	   (T nil)))))

(defmacro pprint-pop+ (args xp)
  `(if (pprint-pop-check+ ,args ,xp)
       (return-from logical-block nil)
       (pop ,args)))

(declaim (ftype (function (t pxp.stream:xp-structure) (values boolean &optional)) pprint-pop-check+top))
(defun pprint-pop-check+top (args xp)
  (incf *current-length*)
  (cond ((not (listp args))  ;must be first so supersedes length abbrev
	 (pxp.stream:write-string++ ". " xp 0 2)
	 (write+ args xp)
	 T)
	((and *print-length* ;must supersede circle check
	      (not (< *current-length* *print-length*)))
	 (pxp.stream:write-string++ "..." xp 0 3)
	 (setq pxp.stream:*abbreviation-happened* T)
	 T)))

(defmacro pprint-pop+top (args xp)
  `(if (pprint-pop-check+top ,args ,xp)
       (return-from logical-block nil)
       (pop ,args)))

(defmacro pprint-logical-block+ ((var args prefix suffix per-line? circle-check? atsign?)
				 &body body)
   (when (and circle-check? atsign?)
     (setq circle-check? 'not-first-p))
  `(let ((pxp.dispatch:*current-level* (1+ pxp.dispatch:*current-level*))
	 (*current-length* -1)
	 (pxp.stream:*parents* pxp.stream:*parents*)
	 ,@(when (and circle-check? atsign?)
	     `((not-first-p (plusp *current-length*)))))
     (unless (check-block-abbreviation ,var ,args ,circle-check?)
       (block logical-block
         (pxp.stream:with-block (,var ,prefix ,per-line? ,suffix)
	   (macrolet ((pprint-pop () `(pprint-pop+ ,',args ,',var))
		      (pprint-exit-if-list-exhausted ()
			`(when (null ,',args)
			   (return-from logical-block nil))))
	     ,@body))))))

(defmacro pprint-logical-block ((stream-symbol list
				 &key (prefix nil) (per-line-prefix nil)
				      (suffix ""))
				&body body)
  (cond ((eq stream-symbol nil) (setq stream-symbol '*standard-output*))
	((eq stream-symbol T) (setq stream-symbol '*terminal-io*)))
  (when (not (symbolp stream-symbol))
    (warn "STREAM-SYMBOL arg ~S to PPRINT-LOGICAL-BLOCK is not a bindable symbol"
	  stream-symbol)
    (setq stream-symbol '*standard-output*))
  (when (and prefix per-line-prefix)
    (warn "prefix ~S and per-line-prefix ~S cannot both be specified ~
           in PPRINT-LOGICAL-BLOCK" prefix per-line-prefix)
    (setq per-line-prefix nil))
  `(pxp.stream:call-with-xp-stream
     #'(lambda (,stream-symbol)
	 (let ((+l ,list)
	       (+p ,(or prefix per-line-prefix ""))
	       (+s ,suffix))
	   (pprint-logical-block+
	     (,stream-symbol +l +p +s ,(not (null per-line-prefix)) T nil)
	     ,@ body nil)))
     (pxp.stream:decode-stream-arg ,stream-symbol)))

(defun pretty-vector (xp v)
  (pprint-logical-block (xp nil :prefix "#(" :suffix ")")
    (let ((end (length v)) (i 0))
      (when (plusp end)
	(loop (pprint-pop)
	      (write+ (aref v i) xp)
	      (when (= (incf i) end)
		(return nil))
	      (pxp.stream:write-char++ #\space xp)
	      (pxp.stream:pprint-newline+ :fill xp))))))

(defun pretty-non-vector (xp array)
  (let* ((bottom (1- (array-rank array)))
	 (indices (make-list (1+ bottom) :initial-element 0))
	 (dims (array-dimensions array))
	 (*prefix* (cl:format nil "#~DA(" (1+ bottom))))
    (labels ((pretty-slice (slice)
	       (pprint-logical-block (xp nil :prefix *prefix* :suffix ")")
		 (let ((end (nth slice dims))
		       (spot (nthcdr slice indices)) ; to avoid inner looping.
		       (i 0)
		       (*prefix* "("))
		   (when (plusp end)
		     (loop (pprint-pop)
			   (setf (car spot) i)
			   (if (= slice bottom)
			       (write+ (apply #'aref array indices) xp)
			       (pretty-slice (1+ slice)))
			   (when (= (incf i) end)
			     (return nil))
			   (pxp.stream:write-char++ #\space xp)
			   (pxp.stream:pprint-newline+ (if (= slice bottom) :fill :linear) xp)))))))
      (pretty-slice 0))))

(defun pretty-array (xp array)
  (cond ((vectorp array) (pretty-vector xp array))
	((zerop (array-rank array))
	 (pxp.stream:write-string++ "#0A " xp 0 4)
	 (write+ (aref array) xp))
	(T (pretty-non-vector xp array))))

(defun write+ (object xp)
  (let ((pxp.stream:*parents* pxp.stream:*parents*))
    (unless (and pxp.stream:*circularity-hash-table*
		(eq (pxp.stream:circularity-process xp object nil) :subsequent))
      (when (and pxp.stream:*circularity-hash-table* (consp object))
	;;avoid possible double check in handle-logical-block.
	(setq object (cons (car object) (cdr object))))
      (let ((printer (if *print-pretty*
		         (pxp.dispatch:get-printer object pxp.dispatch:*print-pprint-dispatch*)
			 nil))
	    type)
	(cond (printer (funcall printer xp object))
	      ((pxp.stream:maybe-print-fast xp object))
	      ((and *print-pretty*
		    (symbolp (setq type (type-of object)))
		    (setq printer (get type 'structure-printer))
		    (not (eq printer :none)))
	       (funcall printer xp object))
	      ((and *print-pretty* *print-array* (arrayp object)
		    (not (stringp object)) (not (bit-vector-p object))
		    (not (pxp.dispatch:structure-type-p (type-of object))))
	       (pretty-array xp object))
	      (T (let ((stuff
			 (with-output-to-string (s)
			   (pxp.dispatch:non-pretty-print object s))))
		   (pxp.stream:write-string+ stuff xp 0 (length stuff)))))))))

(declaim (ftype (function (t stream) (values t &optional)) basic-write))
(defun basic-write (object stream)
  (cond ((pxp.stream:xp-structure-p stream) (write+ object stream))
	(*print-pretty* (pxp.stream:call-with-xp-stream
			  #'(lambda (s o) (write+ o s)) stream object))
	(T (cl:write object :stream stream))))

(defun write (object &rest pairs &key
		     (stream *standard-output*)
		     ((:escape *print-escape*) *print-escape*)
		     ((:radix *print-radix*) *print-radix*)
		     ((:base *print-base*) *print-base*)
		     ((:circle *print-circle*) *print-circle*)
		     ((:pretty *print-pretty*) *print-pretty*)
		     ((:level *print-level*) *print-level*)
		     ((:length *print-length*) *print-length*)
		     ((:case *print-case*) *print-case*)
		     ((:gensym *print-gensym*) *print-gensym*)
		     ((:array *print-array*) *print-array*)
		     ((:pprint-dispatch pxp.dispatch:*print-pprint-dispatch*)
		      pxp.dispatch:*print-pprint-dispatch*)
		     ((:right-margin pxp.stream:*print-right-margin*)
		      pxp.stream:*print-right-margin*)
		     ((:lines pxp.stream:*print-lines*) pxp.stream:*print-lines*)
		     ((:miser-width pxp.stream:*print-miser-width*)
		      pxp.stream:*print-miser-width*))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (cond ((or (pxp.stream:xp-structure-p stream) *print-pretty*)
	 (basic-write object stream))
	#+(or ccl clisp ecl)
	((and (null *print-pretty*)
	      ;; as (typep object '(cons (member quote function) (cons * null)))
	      ;; due to ecl does not support cons-type-specifier.
	      (and (consp object)
		   (member (car object) '(quote function))
		   (consp (cdr object))
		   (null (cddr object))))
	 (funcall (cl:formatter "~:<~W ~W~:>") stream object))
	(T
	  (apply #'cl:write object pairs)))
  object)

(defun print (object &optional (stream *standard-output*))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (terpri stream)
  (let ((*print-escape* T))
    (basic-write object stream))
  (write-char #\space stream)
  object)

(defun prin1 (object &optional (stream *standard-output*))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (let ((*print-escape* T))
    (basic-write object stream))
  object)

(defun princ (object &optional (stream *standard-output*))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (let ((*print-escape* nil))
    (basic-write object stream))
  object)

(defun pprint (object &optional (stream *standard-output*))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (terpri stream)
  (let ((*print-escape* T) (*print-pretty* T))
    (basic-write object stream))
  (values))

(defun write-to-string (object &rest pairs &key &allow-other-keys)
  (with-output-to-string (s)
    (apply #'write object :stream s pairs)))

(defun prin1-to-string (object)
  (with-output-to-string (stream)
    (let ((*print-escape* T))
      (basic-write object stream))))

(defun princ-to-string (object)
  (with-output-to-string (stream)
    (let ((*print-escape* nil))
      (basic-write object stream))))

(locally
  ;; To muffle &OPTIONAL and &KEY is used at once.
  #+sbcl (declare (sb-ext:muffle-conditions style-warning))
(defun write-string (string &optional (stream *standard-output*)
		     &key (start 0) (end (length string)))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (if (pxp.stream:xp-structure-p stream)
      (pxp.stream:write-string+ string stream start end)
      (cl:write-string string stream :start start :end end))
  string)

(defun write-line (string &optional (stream *standard-output*)
		   &key (start 0) (end (length string)))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (if (pxp.stream:xp-structure-p stream)
      (progn (pxp.stream:write-string+ string stream start end)
	     (pxp.stream:pprint-newline+ :unconditional stream))
      (cl:write-line string stream :start start :end end))
  string)
)

(defun fresh-line (&optional (stream *standard-output*))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (cond ((pxp.stream:xp-structure-p stream)
	 (pxp.stream:attempt-to-output stream T T) ;ok because we want newline
	 (when (not (pxp.buffer:left-most-p stream))
	   (pxp.stream:pprint-newline+ :fresh stream)
	   T))
	(T (and (cl:fresh-line stream) t))))

(defun pprint-newline (kind &optional (stream *standard-output*))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (check-type kind pxp.queue:newline-kind)
  (when (pxp.stream:xp-structure-p stream)
    (pxp.stream:pprint-newline+ kind stream))
  nil)

(defun pprint-indent (relative-to n &optional (stream *standard-output*))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (check-type relative-to pxp.queue:indent-kind)
  (when (pxp.stream:xp-structure-p stream)
    (pxp.stream:pprint-indent+ relative-to n stream))
  nil)

(defun pprint-tab (kind colnum colinc &optional (stream *standard-output*))
  (setq stream (pxp.stream:decode-stream-arg stream))
  (check-type kind pxp.stream:tab-kind)
  (when (pxp.stream:xp-structure-p stream)
    (pxp.stream:pprint-tab+ kind colnum colinc stream))
  nil)

(defun pprint-linear (s list &optional (colon? T) atsign?)
     (declare (ignore atsign?))
  (pprint-logical-block (s list :prefix (if colon? "(" "")
			        :suffix (if colon? ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop (write+ (pprint-pop) s)
	  (pprint-exit-if-list-exhausted)
	  (pxp.stream:write-char++ #\space s)
	  (pxp.stream:pprint-newline+ :linear s))))

(defun pprint-fill (s list &optional (colon? T) atsign?)
    (declare (ignore atsign?))
  (pprint-logical-block (s list :prefix (if colon? "(" "")
			        :suffix (if colon? ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop (write+ (pprint-pop) s)
	  (pprint-exit-if-list-exhausted)
	  (pxp.stream:write-char++ #\space s)
	  (pxp.stream:pprint-newline+ :fill s))))

(defun pprint-tabular (s list &optional (colon? T) atsign? (tabsize nil))
  (declare (ignore atsign?))
  (when (null tabsize) (setq tabsize 16))
  (pprint-logical-block (s list :prefix (if colon? "(" "")
			        :suffix (if colon? ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop (write+ (pprint-pop) s)
	  (pprint-exit-if-list-exhausted)
	  (pxp.stream:write-char++ #\space s)
	  (pxp.stream:pprint-tab+ :section-relative 0 tabsize s)
	  (pxp.stream:pprint-newline+ :fill s))))
